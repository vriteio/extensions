var D=Symbol("usableEnv"),r=Symbol("value"),s=Symbol("id"),y=Symbol("componentName"),i={data:{},func:{},views:{},currentScope:null},f={},g=()=>`_${Math.random().toString(36).substring(2,9)}`,u=new Proxy({},{get(t,e){let n=()=>{};return Object.defineProperty(n,y,{value:e}),n}});function C(t){if(!i.data.temp){let a=()=>i.data.temp[r];Object.defineProperty(a,s,{value:"temp"}),Object.defineProperty(a,r,{value:{},writable:!0}),i.data.temp=a}let e=g(),n=a=>{let l=i.data.temp;l[r][e]&&(l[r][e][r]=a)},o=()=>i.data.temp[r][e][r];return Object.defineProperty(o,s,{value:`temp.${e}`}),Object.defineProperty(o,r,{value:t,writable:!0}),i.data.temp[r][e]=o,i.currentScope&&i.currentScope.temp.push(e),[o,n]}var h=t=>{let e=g(),n=t;return Object.defineProperty(n,s,{value:e}),i.func[e]=n,i.currentScope&&i.currentScope.func.push(e),n},c=(t,e,...n)=>({component:t[y]||"Fragment",slot:n,props:Object.fromEntries(Object.keys(e||{}).map(o=>{let a=e[o];return a&&a[s]?[o,a[s]]:[o,a]}))}),x=(...t)=>({component:"Fragment",slot:t,props:{}}),P=t=>{let e=g(),n={[s]:e,[r]:t};return i.views[e]=n,n},k=t=>{let e=f[t];e&&(e.func.forEach(n=>{delete i.func[n]}),e.temp.forEach(n=>{let o=i.data.temp;o()&&delete o()[n]}))},S=t=>({getEnvironment:()=>i,getMetadata:()=>({__value:r,__id:s,__componentName:y,__usableEnv:D}),generateRuntimeSpec:()=>({...t,onUninstall:t.onUninstall?.[s],onConfigure:t.onConfigure?.[s],configurationView:t.configurationView?.[s],contentPieceView:t.contentPieceView?.[s],blockActions:t.blockActions?.map(e=>({...e,view:e.view[s]})),elements:t.elements?.map(e=>({...e,view:e.view[s]}))}),generateView:async(e,n,o)=>{let a=i.views[e]?.[r];if(a){i.currentScope={func:[],temp:[],uid:o};let l=await a(n);return f[`view:${o}`]=i.currentScope,i.currentScope=null,l}return{component:"",slot:[]}},runFunction:async(e,n,o)=>{let a=i.func[e];a&&(i.currentScope={func:[],temp:[],uid:o},await a(n),f[`func:${o}`]=i.currentScope,i.currentScope=null,k(`func:${o}`))},removeScope:k});var L=S({onUninstall:h(async({client:t})=>{let e=await t.webhooks.list({extensionOnly:!0});e.length>0&&t.webhooks.delete({id:e[0].id})}),onConfigure:h(async({client:t,config:e,spec:n})=>{let o=await t.webhooks.list({extensionOnly:!0}),a=e?.autoPublish&&e?.contentGroupId&&e?.publicationId&&e.accessToken;o.length>0?a?await t.webhooks.update({id:o[0].id,url:"https://extensions.vrite.io/hashnode/webhook",metadata:{contentGroupId:`${e.contentGroupId}`}}):await t.webhooks.delete({id:o[0].id}):a&&await t.webhooks.create({name:n.displayName,event:"contentPieceAdded",metadata:{contentGroupId:`${e.contentGroupId}`},url:"https://extensions.vrite.io/hashnode/webhook"})}),configurationView:P(({use:t})=>{let[e]=t("config.accessToken"),[n]=t("config.publicationId"),[o,a]=t("config.autoPublish"),[l,b]=t("config.contentGroupId"),[d]=t("config.requireCanonicalLink");return typeof o()!="boolean"&&a(!0),l()||b(""),c(x,null,c(u.Field,{type:"text",color:"contrast",label:"Access Token","bind:value":e,placeholder:"Access Token"},"Your Hashnode API Access Token. You can generate one in the [Developer Settings](https://hashnode.com/settings/developer), of your Hashnode account."),c(u.Field,{type:"text",color:"contrast",label:"Publication ID","bind:value":n,placeholder:"Publication ID"},"ID of the Hashnode publication/blog you are in and want to publish your posts to. You can find the publication ID in the URL (in form of **hashnode.com/[id]/dashboard**) when visiting your publication's dashboard."),c(u.Show,{"bind:when":o},c(u.Field,{type:"text",color:"contrast",label:"Content group ID","bind:value":l},"Provide ID of a content group to auto-publish from, when content pieces are moved to it. You can copy the ID from the dashboard."),c(u.Field,{type:"checkbox",color:"contrast",label:"Require canonical link","bind:value":d},"Don't auto-publish when no canonical link is set")),c(u.Field,{type:"checkbox",color:"contrast",label:"Auto-publish","bind:value":o},"Publish posts automatically"))}),contentPieceView:P(({config:t,token:e,extensionId:n,notify:o,use:a,flush:l})=>{let b=a("contentPiece"),[d,F]=a("data.hashnodeId"),[v,V]=a("data.autoPublish"),I=!t?.accessToken||!t.publicationId||t.autoPublish&&!t.contentGroupId,[T,w]=C(!1),[A,O]=C(d()?"Update":"Publish"),j=h(async()=>{try{w(!0),await l();let m=await fetch("https://extensions.vrite.io/hashnode",{method:"POST",headers:{Authorization:`Bearer ${e}`,"X-Vrite-Extension-Id":n,"Content-Type":"application/json"},body:JSON.stringify({contentPieceId:b().id})}),p=await m.json();if(!m.ok||!p.hashnodeId)throw new Error("Couldn't publish to Hashnode");d()?o({text:"Updated on Hashnode",type:"success"}):o({text:"Published to Hashnode",type:"success"}),p.hashnodeId&&p.hashnodeId!==d()&&F(p.hashnodeId),w(!1),O("Update"),await l()}catch{o({text:"Couldn't publish to Hashnode",type:"error"}),w(!1),await l()}});return typeof v()!="boolean"&&V(!0),c(u.View,{class:"flex flex-col gap-2"},c(u.Show,{when:t?.autoPublish},c(u.Field,{type:"checkbox",color:"contrast",label:"Auto-publish","bind:value":v,disabled:I},"whether the article should be auto-published")),c(u.Button,{color:"primary",class:"w-full justify-center items-center m-0",disabled:I,"bind:loading":T,"on:click":j},c(u.Text,{"bind:content":A})))})});export{L as default};
